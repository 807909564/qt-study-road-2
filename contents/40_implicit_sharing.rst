.. _implicit_sharing:

`40. 隐式数据共享 <http://www.devbean.net/2013/01/qt-study-road-2-implicit-sharing/>`_
======================================================================================

:作者: 豆子

:日期: 2013年01月21日

Qt 中许多 C++ 类使用了隐式数据共享技术，来最大化资源利用率和最小化拷贝时的资源消耗。当作为参数传递时，具有隐式数据共享的类即安全又高效。在数据传递时，实际上只是传递了数据的指针（这一切都是隐含帮你完成的），而只有在函数发生需要写入的情况时，数据才会被拷贝（也就是通常所说的写时复制）。本章我们将介绍有关隐式数据共享的相关内容，以便为恰当地使用前面所介绍的容器夯实基础。


具有数据共享能力的类包含了一个指向共享数据块的指针。这个数据块包含了数据本身以及数据的引用计数。当共享对象创建出来时，引用计数被设置为 1。当新的对象引用到共享数据时，引用计数增加；当对象引用不再引用数据时，引用计数减少。当引用计数变为 0 时，共享数据被删除。

在我们操作共享数据时，实际有两种拷贝对象的方法：我们通常称其为深拷贝和浅拷贝。深拷贝意味着要重新构造一个全新的对象；浅拷贝则仅仅复制引用，也就是上面所说的那个指向共享数据块的指针。深拷贝对内存和 CPU 资源都是很昂贵的；浅拷贝则非常快速，因为它仅仅是设置一个新的指针，然后将引用计数加 1。具有隐式数据共享的对象，其赋值运算符使用的是浅拷贝来实现的。

这种隐式数据共享的好处是，程序不需要拥有不必要的重复数据，减少数据拷贝的需求。重复数据的代价是降低内存使用率（因为内存存储了更多重复的数据）。通过数据共享，对象可以更简单地作为值来传递以及从函数中返回。

隐式数据共享是在底层自动完成的，程序人员无需关心。这也是“隐式”一词的含义。从 Qt4 开始，即使在多线程程序中，隐式数据共享也是起作用的。在很多人看来，隐式数据共享和多线程是不兼容的，这是由引用计数的实现方式决定的。但是，Qt 使用了原子性的引用计数来避免多线程环境下可能出现的执行顺序打断的行为。需要注意的是，原子引用计数并不能保证线程安全，还是需要恰当的锁机制。这种观点对所有类似的场合都是适用的。原子引用计数能够保证的是，线程肯定操作自己的数据，线程自己的数据是安全的。总的来说，从 Qt4 开始，你可以放心使用隐式数据共享的类，即使在多线程环境下。

我们可以使用 QSharedData 和 QSharedDataPointer 类实现自己的隐式数据共享类。

当对象即将被修改，并且其引用计数大于 1 时，隐式数据共享自动将数据从共享块中拿出。隐式共享类必须控制其内部数据，在任何修改其数据的函数中，将数据自动取出。

QPen 使用了隐式数据共享技术，我们以 QPen 为例，看看隐式数据共享是如何起作用的：

.. code-block:: c++

	void QPen::setStyle(Qt::PenStyle style)
	{
	    detach(); // 从共享区取出数据
	    d->style = style; // 设置数据（更新）
	}
	 
	void QPen::detach()
	{
	    if (d->ref != 1) {
	        ... // 执行深拷贝
	    }
	}

凡是支持隐式数据共享的 Qt 类都支持类似的操作。用户甚至不需要知道对象其实已经共享。因此，你应该把这样的类当作普通类一样，而不应该依赖于其共享的特色作一些“小动作”。事实上，这些类的行为同普通类一样，只不过添加了可能的共享数据的优点。因此，你大可以使用按值传参，而无须担心数据拷贝带来的性能问题。例如：

.. code-block:: c++

	QPixmap p1, p2;
	p1.load("image.bmp");
	p2 = p1; // p1 和 p2 共享数据
	 
	QPainter paint;
	paint.begin(&p2); // 从此，p2 与 p1 分道扬镳
	paint.drawText(0,50, "Hi");
	paint.end();

上例中，p1 和 p2 在 QPainter::begin() 一行之前都是共享数据的，直到这一语句。因为该语句开始，p2 就要被修改了。

注意，前面已经提到过，不要在使用了隐式数据共享的容器上，在有非 const STL 风格的遍历器正在遍历时复制容器。另外还有一点，对于 QList 或者 QVector，我们应该使用 at() 函数而不是 [] 操作符进行只读访问。原因是 [] 操作符既可以是左值又可以是右值，这让 Qt 容器很难判断到底是左值还是右值，这意味着无法进行隐式数据共享；而 at() 函数不能作左值，因此可以进行隐式数据共享。另外一点是，对于 begin()，end() 以及其他一些非 const 遍历器，由于数据可能改变，因此 Qt 会进行深复制。为了避免这一点，要尽可能使用 const_iterator、constBegin() 和 constEnd()。
